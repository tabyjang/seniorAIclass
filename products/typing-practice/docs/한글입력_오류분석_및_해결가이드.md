# 한글 입력 오류 분석 및 해결 가이드

> **작성일:** 2026-02-02
> **대상:** 시니어 타자 연습 앱
> **목적:** 한글 입력 시 발생하는 오류 원인 분석 및 해결 방법 정리

---

## 1. 한글 입력의 특수성

### 1.1 조합형 입력 방식

한글은 **조합형(Precomposition)** 방식으로 입력됩니다:

```
입력 순서: ㅇ → 오 → 온 → 온ㄴ → 온라 → 온라ㅇ → 온라인
입력 횟수: 1    2    3     4      5      6       7 (글자)
          ↑    ↑    ↑     ↑      ↑      ↑       ↑
        조합중 조합중 완성  조합중  조합중  조합중   완성
```

**핵심 문제:** 한 글자를 완성하기 위해 여러 번의 키 입력이 필요함

---

## 2. 발생하는 주요 오류들

### 2.1 🐛 오류 1: 조합 중 정답 체크 실패

**증상:**
- "안녕하세요" 입력 시 "안녕하세"까지만 입력해도 다음 문장으로 넘어감
- 마지막 글자가 조합 중일 때 완성된 것으로 처리됨

**원인:**
```javascript
// 문제 코드
if (input === currentSentence) {
    // 다음 문장으로...
}
```

- input 값은 조합 중인 중간 상태도 포함됨
- "안녕하세요"를 입력할 때 마지막 '요'가 완성되기 전인 "안녕하세" 상태에서도 체크가 됨
- `isComposing` 플래그가 있지만 `displaySentence()`에서는 조합 중인 글자도 길이로 카운트됨

---

### 2.2 🐛 오류 2: 정확도 계산 오류

**증상:**
- 한 글자를 입력하는 동안 정확도가 급변함
- 100% → 50% → 100% 로 진동

**원인:**
```javascript
// checkInput 함수
totalChars += currentSentence.length;
correctChars += currentSentence.length;
```

- 조합 중인 글자(예: "ㄱ")도 글자 수로 카운트됨
- 실제로는 "가"를 입력 중인데, "ㄱ"과 ""를 비교하여 오답 처리

---

### 2.3 🐛 오류 3: 백스페이스 처리 문제

**증상:**
- 조합 중 백스페이스를 누르면 화면 표시가 어긋남
- 이미 입력한 글자가 초록색에서 빨간색으로 바뀜

**원인:**
```javascript
for (let i = 0; i < currentSentence.length; i++) {
    if (i < input.length) {  // ← 여기서 input.length가 조합 중에도 증가
        // 맞/틀 체크
    }
}
```

- 조합 중인 글자도 `input.length`에 포함됨
- 백스페이스로 조합을 취소해도 이전 상태가 제대로 복원되지 않음

---

### 2.4 🐛 오류 4: 현재 위치 표시 어긋남

**증상:**
- 노란색 하이라이트(현재 위치)가 실제 입력 위치와 다름
- 특히 받침(ㄱ, ㄴ, ㄹ 등)을 입력할 때 문제 발생

**원인:**
```javascript
} else if (i === input.length) {
    // 현재 입력 위치
    if (isComposing) {
        className += ' composing';
    } else {
        className += ' current';
    }
}
```

- 조합 중일 때 `input.length`는 실제 완성된 글자 수보다 많음
- 예: "가"를 입력 중 (ㄱ → 가)일 때 input.length는 1→2로 변하지만, 실제 완성된 글자는 1개

---

### 2.5 🐛 오류 5: 이벤트 중복 발생

**증상:**
- 한 글자 입력 시 여러 번 체크됨
- 통계가 중복 계산됨

**원인:**
```javascript
typingInput.addEventListener('compositionend', function() {
    isComposing = false;
    checkInput(); // ← compositionend에서 체크
});

typingInput.addEventListener('input', function() {
    if (!isComposing) {
        checkInput(); // ← input에서도 체크
    }
});
```

- `compositionend` 후 `input` 이벤트가 한 번 더 발생
- `checkInput()`이 두 번 호출되어 통계 중복 계산

---

## 3. 해결 방법

### 3.1 ✅ 해결 1: 완성된 텍스트만 체크

**방법:** `compositionend`에서만 정답 체크

```javascript
let isComposing = false;
let completedText = ''; // 완성된 텍스트만 저장

typingInput.addEventListener('compositionstart', function() {
    isComposing = true;
});

typingInput.addEventListener('compositionend', function(e) {
    isComposing = false;
    completedText = e.target.value; // 완성된 값 저장
    checkInput();
});

typingInput.addEventListener('input', function(e) {
    if (!isComposing) {
        completedText = e.target.value;
        checkInput();
    }
    displaySentence(); // 화면 표시는 항상 업데이트
});
```

---

### 3.2 ✅ 해결 2: 글자 단위 비교 개선

**방법:** 조합 중인 글자는 체크에서 제외

```javascript
function checkInput() {
    // 한글 조합 중이면 완성 여부만 체크
    if (isComposing) return;
    
    const input = completedText || typingInput.value;
    
    // 글자 단위로 정확히 비교
    for (let i = 0; i < input.length; i++) {
        if (i >= currentSentence.length) break;
        
        // 이미 계산한 글자는 건너뛰기
        if (i < checkedLength) continue;
        
        totalChars++;
        if (input[i] === currentSentence[i]) {
            correctChars++;
        }
    }
    
    checkedLength = input.length;
    
    // 정답 체크는 완성된 후에만
    if (input === currentSentence) {
        handleCorrect();
    }
}
```

---

### 3.3 ✅ 해결 3: 정확도 계산 시점 조정

**방법:** 문장 완료 시 한 번에 계산

```javascript
function checkInput() {
    // 조합 중이면 화면 표시만
    if (isComposing) {
        displaySentence();
        return;
    }
    
    const input = typingInput.value;
    displaySentence();
    
    // 정답 체크는 완성된 후에만
    if (input === currentSentence) {
        // 문장 완료 시 한 번에 계산
        totalChars += currentSentence.length;
        
        // 정확히 일치하는 글자 수 계산
        let correct = 0;
        for (let i = 0; i < currentSentence.length; i++) {
            if (input[i] === currentSentence[i]) correct++;
        }
        correctChars += correct;
        
        handleNextSentence();
    }
}
```

---

### 3.4 ✅ 해결 4: 현재 위치 표시 정확히 하기

**방법:** 완성된 글자 수 기준으로 위치 계산

```javascript
function displaySentence() {
    const display = document.getElementById('sentenceDisplay');
    const input = typingInput.value;
    
    // 완성된 글자 수 계산 (조합 중인 글자 제외)
    const completedLength = isComposing 
        ? input.length - 1  // 마지막 글자는 조합 중
        : input.length;
    
    let html = '';
    for (let i = 0; i < currentSentence.length; i++) {
        let className = 'char';
        
        if (i < completedLength) {
            // 완성된 글자 비교
            if (input[i] === currentSentence[i]) {
                className += ' correct';
            } else {
                className += ' incorrect';
            }
        } else if (i === completedLength) {
            // 현재 입력 위치
            className += isComposing ? ' composing' : ' current';
        }
        
        html += `<span class="${className}">${currentSentence[i]}</span>`;
    }
    
    display.innerHTML = html;
}
```

---

### 3.5 ✅ 해결 5: 중복 이벤트 방지

**방법:** 플래그로 중복 체크 방지

```javascript
let isChecking = false; // 중복 체크 방지 플래그

function checkInput() {
    if (isChecking) return; // 이미 체크 중이면 무시
    if (isComposing) return; // 조합 중이면 무시
    
    isChecking = true;
    
    try {
        const input = typingInput.value;
        displaySentence();
        
        if (input === currentSentence) {
            handleCorrect();
        }
    } finally {
        isChecking = false;
    }
}

// 이벤트 리스너
typingInput.addEventListener('compositionend', function() {
    isComposing = false;
    // requestAnimationFrame으로 중복 방지
    requestAnimationFrame(() => checkInput());
});

typingInput.addEventListener('input', function() {
    if (!isComposing) {
        requestAnimationFrame(() => checkInput());
    } else {
        displaySentence();
    }
});
```

---

## 4. 완전한 수정된 코드 예시

```javascript
// 상태 변수
let isComposing = false;
let isChecking = false;
let lastInput = '';

// 이벤트 리스너 설정
const typingInput = document.getElementById('typingInput');

// 조합 시작
typingInput.addEventListener('compositionstart', () => {
    isComposing = true;
});

// 조합 종료
typingInput.addEventListener('compositionend', (e) => {
    isComposing = false;
    lastInput = e.target.value;
    
    // 약간의 지연으로 중복 체크 방지
    setTimeout(() => {
        checkInput();
    }, 0);
});

// 입력 이벤트
typingInput.addEventListener('input', (e) => {
    if (isComposing) {
        // 조합 중에는 화면 표시만
        displaySentence();
    } else {
        // 완성 후 체크
        lastInput = e.target.value;
        checkInput();
    }
});

// 입력 체크 함수
function checkInput() {
    if (isChecking || isComposing) return;
    
    isChecking = true;
    
    try {
        const input = lastInput;
        
        // 화면 업데이트
        updateDisplay(input);
        
        // 정답 체크 (완성된 후에만)
        if (input === currentSentence && !isComposing) {
            handleCorrectAnswer();
        }
    } finally {
        isChecking = false;
    }
}

// 화면 표시 업데이트
function updateDisplay(input) {
    const display = document.getElementById('sentenceDisplay');
    
    // 완성된 글자 수
    const completedLength = isComposing ? input.length - 1 : input.length;
    
    let html = '';
    for (let i = 0; i < currentSentence.length; i++) {
        let className = 'char';
        
        if (i < completedLength) {
            // 완성된 글자
            className += input[i] === currentSentence[i] ? ' correct' : ' incorrect';
        } else if (i === completedLength && isComposing) {
            // 조합 중인 위치
            className += ' composing';
        } else if (i === completedLength) {
            // 현재 입력 위치
            className += ' current';
        }
        
        html += `<span class="${className}">${currentSentence[i]}</span>`;
    }
    
    display.innerHTML = html;
}

// 정답 처리
function handleCorrectAnswer() {
    sentenceCount++;
    
    // 정확도 계산
    const input = lastInput;
    let correct = 0;
    for (let i = 0; i < currentSentence.length; i++) {
        if (input[i] === currentSentence[i]) correct++;
    }
    
    totalChars += currentSentence.length;
    correctChars += correct;
    
    updateStats();
    
    if (sentenceCount >= totalSentences) {
        endGame();
    } else {
        showMessage('잘하셨어요! 👏', 'success');
        setTimeout(() => {
            currentIndex++;
            loadSentence();
        }, 800);
    }
}
```

---

## 5. 테스트 체크리스트

### 5.1 한글 입력 테스트

| 테스트 | 방법 | 기대 결과 |
|--------|------|-----------|
| 기본 입력 | "안녕하세요" 입력 | 조합 중 초록/빨강 표시, 완성 후 다음 문장 |
| 받침 입력 | "감사합니다" 입력 | ㄱ→감→사→합... 순서로 정상 표시 |
| 쌍자음 | "쌍둥이" 입력 | ㅆ→쌍 순서로 정상 표시 |
| 모음 조합 | "왜" (ㅇ+ㅗ+ㅐ) 입력 | ㅇ→오→왜 순서로 정상 표시 |

### 5.2 백스페이스 테스트

| 테스트 | 방법 | 기대 결과 |
|--------|------|-----------|
| 조합 중 백스페이스 | "가" 입력 중 ㄱ→백스페이스 | 이전 글자 상태로 복원 |
| 완성 후 백스페이스 | "안녕" 입력 후 백스페이스 | "안"까지만 표시, 색상 유지 |

### 5.3 정확도 테스트

| 테스트 | 방법 | 기대 결과 |
|--------|------|-----------|
| 완벽 입력 | 문장을 틀리지 않고 입력 | 정확도 100% |
| 오타 후 수정 | "안령"→"안녕"으로 수정 | 최종 정확도만 반영 |
| 중간 통계 | 입력 중 정확도 확인 | 변동 없이 안정적 |

---

## 6. 추가 고려사항

### 6.1 한글 자모 분리 문제 (실제 사례)

#### 🐛 실제 발생한 문제

**증상:** "맛있게드세요"를 정확히 입력했는데 "드"가 빨간색(오답)으로 표시됨

**원인:** 같은 글자인데도 컴퓨터가 다른 것으로 인식

#### 📚 한글 저장 방식 2가지

컴퓨터는 "가"를 두 가지 방법으로 저장할 수 있음:

| 방식 | 설명 | 예시 |
|------|------|------|
| **NFC (완성형)** | 한 글자로 저장 | `가` = U+AC00 |
| **NFD (분해형)** | 자모로 분리해서 저장 | `가` = ㄱ + ㅏ = U+1100 U+1161 |

**문제:** 정답은 NFC로 저장됐는데, 사용자 입력은 NFD로 저장될 수 있음

```javascript
// 비교 예시
const answer = "맛있게드세요";     // NFC 방식 (정답)
const input = "맛있게드세요";       // NFD 방식 (사용자 입력)

// 눈으로 보면 똑같아 보이지만...
console.log(answer === input);      // false! (틀렸다고 나옴)

// 내부 코드 비교
console.log(answer.charCodeAt(3));  // 46300 (드 - 완성형)
console.log(input.charCodeAt(3));   // 4357  (ㄷ) + 4469 (ㅡ) + 12623 (ㅡ)
```

#### ✅ 해결 방법: normalize('NFC')

모든 한글을 **완성형(NFC)**으로 통일해서 비교:

```javascript
function displaySentence() {
    const display = document.getElementById('sentenceDisplay');
    const input = document.getElementById('typingInput').value;
    
    // 🔑 핵심: 한글 정규화 (NFC 방식으로 통일)
    const normalizedInput = input.normalize('NFC');
    const normalizedSentence = currentSentence.normalize('NFC');
    
    // 이제 비교하면 정확히 맞춰짐!
    for (let i = 0; i < normalizedSentence.length; i++) {
        if (normalizedInput[i] === normalizedSentence[i]) {
            // 맞음 (초록색)
        } else {
            // 틀림 (빨간색)
        }
    }
}
```

#### 🔧 적용해야 할 모든 함수

정규화가 필요한 함수 3개:

1. **displaySentence()** - 화면 표시
2. **checkInput()** - 정답 체크
3. **nextSentence()** - 다음 문장 (통계 계산)

```javascript
// 모든 곳에 추가
const normalizedInput = input.normalize('NFC');
const normalizedSentence = currentSentence.normalize('NFC');
```

#### 🧪 테스트 방법

1. "맛있게드세요" 입력
2. 모든 글자가 초록색으로 표시되는지 확인
3. 정확도 100%로 표시되는지 확인

#### 📖 참고

- **NFC:** Normalization Form Canonical Composition (완성형)
- **NFD:** Normalization Form Canonical Decomposition (분해형)
- 대부분의 한국어 키보드는 NFC를 사용하지만, 일부 조합 방식에서는 NFD가 발생할 수 있음

### 6.2 특수 문자 처리

```javascript
// 숫자/영어/특수문자는 조합이 필요 없음
function needsComposition(char) {
    const code = char.charCodeAt(0);
    // 한글 음절 범위: U+AC00 ~ U+D7A3
    return code >= 0xAC00 && code <= 0xD7A3;
}
```

---

## 7. 요약

| # | 문제 | 핵심 원인 | 핵심 해결책 |
|---|------|----------|------------|
| 1 | 조합 중 정답 체크 | input 값에 중간 상태 포함 | `isComposing` 플래그 체크 |
| 2 | 정확도 진동 | 조합 중 글자도 카운트 | 완성 후 한 번에 계산 |
| 3 | 백스페이스 어긋남 | input.length 불일치 | 완성된 글자 수 기준 |
| 4 | 위치 표시 오류 | 현재 위치 계산 오류 | completedLength 사용 |
| 5 | 중복 체크 | 이벤트 중복 발생 | `isChecking` 플래그 |
| 6 | **같은 글자인데 틀림** ⭐ | NFC vs NFD 방식 차이 | `.normalize('NFC')` 사용 |

---

*이 문서는 시니어 타자 연습 앱의 한글 입력 문제를 해결하기 위해 작성되었습니다.*
